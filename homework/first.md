# 概述

DSR协议意为动态源路由协议，是在移动节点组成的多条无线自组网络中应用的路由协议。该协议主要由“路由发现”和“路由维护”两个机制组成。二者协同工作允许节点发现并维护到自组网中任一目的点的路由。协议的所有方面都是按需操作的，允许DSR路由数据包的开销自动适配到应对当前路由变化所需的大小。该协议允许到任一目的地的多条路由，并且允许每个发送方选择控制发送数据包时使用的路由。这种机制可用于实现负载平衡和增强数据传送的稳定性。

# 详细处理

## 1.常规包处理

### 1.1初始化一个包

包结构的定义如下(dsr-pkt.h)：

![avatar](E:\network\homework\包结构定义.png)

dsr_pkt_alloc(dsr-pkt.h)用于初始化一个包：

![avatar](E:\network\homework\初始化包.png)

​	首先，在该节点的路由缓存中搜索数据包首部目标IP地址字段对应地址的路由。

​	如果在路由缓存中没有找到这样的路由，则对目标地址执行路由发现操作。对目标地址执行路由发现操作会在这个现有的包添加一个路由请求选项（RREQ_OPT）,或者将现有的数据包保存到缓冲区并通过发送一个包含以上路由请求的选项的数据包来启动路由发现。如果选择前者，数据包首部的目的IP地址将被替换为广播地址（255.255.255.255），原始的目的IP地址被复制到新的路由请求的目的地址字段选项添加到数据包中。

​	如果数据包现在不包含路由请求选项，则该节点必须具有到数据包的目的地址的路由；如果节点有不止一条到该目的地址的路由，则由节点选择一条路由进行数据包的转发。如果选择的路径的长度大于一跳，或者当前节点决定在这条路由的第一条请求一个DSR层级的ACK，将在当前数据包中插入一个DSR选项头和DSR源路由选项。

​	然后将数据包发送到选定路由中给定的第一跳节点地址，同时利用路由维护机制来确保下一跳的可达性。

### 1.2将DSR选项头添加进数据包中

![avatar](E:\network\homework\添加选项头.png)

​	28-40: 首先定义每个选项头的固定部分，之后判断如果长度足够，则开始装载相关设置，将参数中缓冲区指针强制类型转换为一个指向DSR选项头的指针。Next header字段设置为数据分组的IP头的协议号，最后返回该指针。

​	具体分析：

​	发送包的节点在必要时向包添加DSR选项头，以携带路由协议所需的信息。一个包不能包含多于一个DSR选项头。DSR选项头通过执行以下步骤添加到包中：

​		-在IP首部后面插入DSR选项头，但要在可能出现的任何其他首部之前插入。

​		-将DSR选项头的下一个首部字段设置为数据包的IP首部的协议号字段。

​		-将数据包IP首部的协议字段设置为分配给DSR的协议号。

### 1.3将DSR源路由选项添加进包中

RFC文档给出DSR源路由选项的定义(Page 47):

​	![avatar](E:\network\homework\RFC源路由选项.png)

DSR源路由选项结构体：

![avatar](E:\network\homework\DSR源路由选项.png)

​	23-42：sleft记录剩余路段的数量，即在到达最终目的地之前仍需要访问的中间节点的数量。变长数组addrs记录源路由的路径信息。其他字段同上。

​	发起分组的节点在需要时向分组添加DSR源路由选项，以便将来自该始发节点的源路由携带到分组的最终目的地址。

添加源路由选项：

![avatar](E:\network\homework\添加源路由选项.png)

​	297-312：选项头固定部分定义，缓冲区长度判断及指针转换同上，然后开始装载选项字段，将类型设置为源路由选项，初始化长度，标志位，抢救次数等，随后数据分组中的地址被复制到DSR源路由选项中的addrs数组字段。

​	具体分析：

​	如果需要，发送数据包的节点向数据包中添加DSR源路由选项，以确保将源路由信息从该节点传送到数据包的最终目的地址。具体来说，添加DSR源路由选项的节点构造DSR源路由选项，并按照以下步骤修改IP数据包：

​		-节点创建DSR源路由选项，并将其追加到包中的DSR选项头。

​		-DSR源路由选项（n）中包含的Address[i]字段的数量是源路由中的中间节点数量。DSR源路由选项中的segment left字段初始化为n。

​		-数据包源路由中的地址被复制到DSR源路由选项中的顺序地址[i]字段中，其中 i= 1,2,…,n。

​		-DSR源路由选项中的(F)位(First Hop External)是从标记包源路由中第一跳的外部位复制的，如路由缓存中所示。

​		-DSR源路由选项中的(L)位(Last Hop External)是从标记包源路由中最后一跳的外部位复制的，如路由缓存中所示。

​		-DSR源路由选项中的打捞字段(补救字段)初始化为 0。

### 1.4 处理一个接收到的包

​	当一个节点收到任何数据分组时，如果该数据分组包含一个DSR选项头，那么该节点必须处理该DSR选项头中包含的所有选项。处理路由请求的代码实现如下：

![avatar](E:\network\homework\dsr_recv1.png)

​	31-43:节点会跟据数据包携带的选项来进行不同的处理操作，调用的dsr_opt_recv函数通过对数据包中选项的类型进行识别然后返回对应的操作类型，随后使用switch语句根据返回的操作类型进行不同的操作，在这些分支中这里着重分析较为复杂的转发请求（DSR_PKT_FORWARD），代码如下：

![avatar](E:\network\homework\dsr_recv_case_forward.png)

​	首先进行生存期ttl的判断，如果ttl小于一（即为0）则丢弃数据包，否则调用XMIT函数转发数据包，XMIT说如下函数dsr_dev_xmit的宏定义，函数代码如下：

![avatar](E:\network\homework\dsr_xmit1.png)

​	其中，结构体sk_buff与m_buf类似，是linux系统中各层协议之间传递数据的重要载体，net_device结构体用来描述一个网络设备，dst字段标记目标地址：

![avatat](E:\network\homework\dsr_xmit_p2.png)

​	

497-507: 通过锁来实现dsr_node(描述当前节点信息)的并发安全性，将抢救网卡设备指定为当前节点的相应设备字段，随后调用dsr_skb_create函数（装填相关字段信息并返回一个sk_buff的指针）创建数据分组。

515-538：随后开始向创建后的数据分组中装填mac地址相关字段，并调用dev_queue_xmit函数进行发送。

​	具体分析：

​	当某个节点接收到一个数据包时，如果这个数据包包含DSR选项头，该节点必须处理所有包含在该DSR选项头中的选项，步骤如下：

​	如果选项头中包含一个路由请求选项（路由发现），节点应该从路由请求中提取源路由，并将该路由信息添加到自己的路由缓存中。路由请求中的路由信息序列是地址发起者，地址[1]，地址[2]，...，地址[n]。每个地址是通过这条路由请求已经经过的节点。这里n是路由请求选项中记录的地址数。

​	在可能更新节点的路由缓存已响应路由请求选项中的路由信息之后，节点必须按照2.2节所述方式处理路由请求选项。

​	如果DSR选项头包含路由应答选项，节点应该从路由应答中提取源路由，并将该路由信息添加到其路由缓存中。

​	在可能更新节点的路由缓存已响应路由应答选项中的路由信息之后，如果数据包的IP目的地址与该节点的某个IP地址匹配，则节点必须按照2.6节所述方式处理路由应答选项。

​	如果DSR选项头包含ACK选项，节点应将从ACK源地址字段标识的节点到ACK目的地址字段表示的节点的单个链路添加到路由缓存。

​	在可能响应已确认选项中的路由信息更新节点的路由缓存之后，节点必须继续处理3.3节中描述的确认选项。

​	如果DSR选项头包含DSR源路由选项，节点应该从DSR源路由中提取源路由，并将该路由信息添加到其路由缓存中。如果打捞字段的值在DSR源路由选项是零，然后从DSR路由信息的源路由的顺序跳地址，如果打捞非零，从DSR路由信息来源途径是跳地址的顺序的值是在源中的源地址字段IP首部的数据包携带DSR源路由选项（原始数据报的发送者），每个地址[i]是DSR源路由中的地址[i]字段的值，目的地址是数据包的IP首部中目标地址字段的值（源路由的最后一跳地址）。

​	最后，如果数据包IP首部中的目标地址与该接收节点的IP地址（es）匹配，则删除DSR选项头和头部中包含的所有DSR选项，并将剩余的数据包向上传递到网络层。

### 1.5处理收到的DSR源路由选项

​	当一个节点收到一个包含DSR源路由选项的数据包时，该节点应检查数据包以确定是否可以进行自动缩短路由。具体来说，如果一个节点不是该数据分组的下一跳地址，但是在路由信息的后续地址中有该节点的地址，则应执行自动路径缩短，代码实现如下：

![avatar](E:\network\homework\route shortening.png)

​	432-439:判断是否可以进行路由缩短：如果节点自身地址并非下一跳地址，并且在路由后续地址中查找到了自己的地址的同时自身应答列表中尚没有该路由回复，则调用dsr_srt_shortcut函数进行路由缩短，返回一个缩短后的源路由选项结构srt_cut。

​	447-461:如果缩短后剩余节点的个数为0（即节点自身为目的节点），则直接调用dsr_srt_new_rev函数将srt_cut中的路径进行反转（因为要向源节点发送应答，需原路返回）。如果自身不是目的节点，则调用dsr_srt_new_split_rev函数，该函数会先调用dsr_srt_new_split函数进行分割（切割掉多余的路径），将路径信息切割至自身节点后再调用dsr_src_new_rev函数进行反转。随后该节点会使用反转后的路由信息向源节点发送应答数据包，该数据包携带有源节点到该节点缩短后的路由信息。

​	如果不能缩短路由信息，则直接转发数据包。

​	具体分析：

​	当节点接收到包含DSR源路由选项的数据包时(无论时转发，窃听，还是作为数据包的最终目的地)，该节点应检查数据包，以确定收到该数据包是否意味着自动缩短路由的机会。具体来说，如果这个节点不是这个包的下一跳但在数据包的DSR源路由选项中被作为后续路由中不可避免地部分，那么说明这个数据包有自动缩短路由的机会。在这种情况下，该节点应执行以下步骤序列，来自动缩短路由：

​	-节点搜索其免费路由应答表，以查找描述该节点早先发送的无偿路由应答的条目，触发无偿路由应答的数据包的原始发送方和为了触发无偿路由应答而从其窃听该数据包的发送节点，两者都匹配这个新接收的数据包的节点地址。如果在节点的免费路由应答表中发现了这样的条目，则节点不应该执行自动路由缩短。

​	-否则，节点将在其免费路由应答表中为该窃听数据包创建一个条目。这个新条目的超时值应初始化为GratReplyHoldoff。此超时过期后，节点应从其免费路由应答表中删除此条目。

​	-在创建上述新的免费路由应答表条目之后，节点将对该窃听包的IP源地址发起免费路由应答。

​		如果在网络中使用的MAC协议不能通过单向链路传输单播分组，那么在发起此路由应答时，节点必须使用源路由来路由应答分组，该路由应答分组时通过反向触发无偿路由应答的分组被路由到的跳序列而获得的。

​	-丢弃窃听到的数据包，因为数据包是在其跟据源路由到达节点之前收到的。该数据包的另一个副本通常会按照源路由指示到达该节点；丢弃包的初始副本能够防止数据包的冗余。

​	如果上述自动路由缩短过程没有丢弃数据包，则节点必须按照一下步骤顺序处理DSR源路由选项：

​	-如果DSR源路由选项中剩余字段（Left field）值为0，那么从DSR选项头中删除DSR源路由选项。

​	-否则，让n等于（Option Data Len - 2）/4。这是DSR源路由选项中的地址数。

​	-如果剩余字段值大于n，则发送一个指向剩余字段的ICMP参数问题到源IP地址，丢弃数据包。不对DSR源路由选项进行进一步处理。

​	-否则，将剩余字段的值减1。让i等于n与剩余字段的差值。这是地址向量中要访问的下一个地址的索引。

​	-如果地址[i]或IP目标地址是组播地址，则丢弃数据包。不对DSR源路由选项进行进一步处理。

​	-如果这个节点有多个网络接口，并且地址[i]是这个节点的一个网络接口的地址，那么这表示在转发数据包时使用的网络接口发生了变化。在这种情况下，将剩余字段值减1，以跳过这个地址（表示网络接口更改），并转到上面的第一步（检查剩余字段的值），继续处理这个源路由选项；在进一步处理这个源路由选项时，必须使用指定的新网络接口转发数据包。

​	-如果该链路上一个节点传输给地址[i]的最大传输单元(MTU)小于数据包的大小，则该节点要么选择丢弃数据包并发送一个信息为Packet Too Big的ICMP数据包给这个包的源地址，要么将其分割成小的数据单元进行发送。

​	-遵循正常的IP转发过程，包括检查和减少数据包IP首部的TTL字段，将数据包转发到IP首部地址[i]字段中指定的IP地址。在数据包的转发过程中，下一跳节点必须被视为一个直接邻居节点：到下一个节点的传输必须在一个IP转发跳中完成，不需要路由发现，也不需要搜索路由缓存。

​	-在转发包时，通过验证下一跳节点是可达的来实现对下一跳的路由维护。

​	多播地址不能出现在DSR路由选项中，也不能出现在在DSR选项头中带有DSR源路由选项的包的IP目标地址字段中。

## 2.路由发现

​	路由发现发生在当网络中的某个源节点S要向目的节点D发送数据并且S不知道通向D的路由时，目的是帮助源节点获得到达目的节点的路由。

​	当源节点S需要向目的节点D发送数据时，它首先查询路由缓存是否有通向D的路由，如果有则将该路由信息附加到数据包头部进行发送。如果没有，则发起路由发现过程。源节点向邻居节点以洪泛方式发送路由请求，以此启动路由发现。随后每个中间节点接收后判断是否存储有到目的节点的路由，若不含有，则将自己的地址加入请求数据中的路由记录并继续转发给邻居节点（如果是目的节点D收到该请求，则会返回路由回复，路由回复中包含所请求的路径信息）。当源节点收到路由回复后，将收到的路径信息存储在自己的路由缓存中，路由发现过程结束。

​	在扩展的路由发现过程里，每个节点还可以从转发的数据包头部中学习到路径信息并保存在自己的路由缓存中。同时如果中间节点在自己的路由缓存中找到了源节点请求的路由信息，也会返回一个路由回复而不是继续转发该路由请求。

### 2.1 一个例子

​	假设节点A发起了对E的路由请求，该路由发现的处理过程如下：

![avatar](E:\network\homework\RFC路由请求.png)

​	初始化路由发现时，节点A向无线传输范围内所有节点发送一个本地广播数据包，在本例中，节点B接收到了该数据包。每个路由请求表示路由发现的发起者和目标，并且还包含由请求发起者确定的唯一请求标识（在这里为2）。每个路由请求还包含一个记录，其中列出转发路由请求的这个特定副本的每个中间节点的地址。此路由记录由路由发现的发起者初始化为一个空列表。在本例中，路由记录最初只列出节点A。

​	当另一个节点接收到此路由请求（如节点B）时，如果它是路由发现的目标，它将向路由发现的发起者返回一个“路由应答”，并从该路由请求中获得累计路由记录的副本；当发起者收到此路由应答时，它将此路由缓存在其路由缓存中，以便在将后续数据包发送到此目的地时使用。

​	否则，如果接收路由请求的此节点最近看到来自此发起者的另一条路由请求信息，该信息带有相同的请求标识和目的地址，或者如果该节点自己的地址已经在路由请求中的路由记录中列出，则该节点将丢弃该请求。（节点会考虑最近看到的请求，如果它在路由请求表中仍然有关于该请求的信息。否则，该节点将自己的地址附加到路由请求中的路由记录，并通过将其作为本地广播包进行传播）。本例中，节点C收到节点B广播的路由请求，节点C，D也依次广播请求，导致节点E收到请求的副本。

​	在对路由发现给出路由回复时，在这里也就是节点E回复节点A。节点E通常会检查自己的路由缓存，如果发现到达A的路径，将使用它的源路由数据包包含路由应答。否则，节点E应执行自己的对于A的路由发现。但为了避免可能出现的无限递归的路由发现，它必须在路由请求的数据包中包含对A的路由回复。同时也可以捎带其他小数据包，比如TCP SYN包。

​	另外，节点E可以简单地反转它试图在路由应答中发送的路由记录中的跳序列，并将其作为承载路由应答本身的数据包上的源路由。

​	在启动路由发现时，发送节点将原始数据包（触发路由发现的数据包）的副本保存在称为“发送缓冲区”的本地缓冲区中。发送缓冲区包含这个节点不能传输的每个数据包的副本，因为它还没有到包的目的地址的源路由。发送缓冲区中的每个包在逻辑上与它被放入发送缓冲区的时间相关联，并在主流发送缓冲区一段超时时间后被丢弃；如果需要防止发送缓冲区溢出，也可以使用FIFO或其他替换策略在数据包过期之前将其逐出。

### 2.2发起路由请求

​	为某个目标发起路由发现的节点在某个IP包的DSR选项头中创建并初始化路由请求选项。

​	路由请求选项结构图：

![avatar](E:\network\homework\RFC路由请求选项.png)

源码如下：

![avatar](E:\network\homework\路由请求选项源码.png)

​	20-21:选项通用部分，选项类型和长度。

​	22:id由路由请求的发起者设置，以此作为每个请求的唯一标识，同时id值也使得每个接收节点可以识别它是否已经接受过同一请求，如果接收节点在自己的路由请求表中发现了该id值（对于特定的源IP地址和目的地址该id是唯一的），那么这个节点就会忽略本次路由请求。

​	23:target记录路由请求的目的节点地址。

​	24:addrs变长数组用以记录路由请求传播路径上的每个节点的地址信息。地址数量由该选项中的length指定，id和target共占6个字节，每个ip地址4个字节，故n=(length-6)/4

​	路由请求选项不得在一个DSR选项头中出现超过一次。

​	启动路由发现的节点会在某个IP数据包的DSR选项头中创建并初始化一个路由选项。这可以是一个单独的IP数据包，仅用于执行此路由请求选项，也可以在某些需要发送到目标结节点的现有数据包中包含路由请求选项。需要完成的步骤有1.添加到本地路由请求表  2.发送路由请求。代码实现如下：

![avatar](E:\network\homework\路由发现1.png)

​	352-360:首先通过 _tbl_find函数在路由请求表中查找是否有相同目的地址的路由请求，如果没有则调用 _rrep_tbl_add函数直接添加进路由请求表，否则先删除原有记录，再调用 _tbl_add_tail添加进路由请求表中的最后（使用先进先出的管理策略，如果请求表满会先删除第一条记录）。其中 _rreq_tbl_add函数主要调用 _rreq_tbl_entry_create函数，代码如下：

![avatar](E:\network\homework\添加进路由请求表.png)

![avatar](E:\network\homework\entry_create.png)

​	206-235:首先为该条请求记录申请内存空间，然后开始装填状态，目标地址，生存期ttl等字段。最后需要为每条请求初始化一个唯一表示id，避免被无限转发。